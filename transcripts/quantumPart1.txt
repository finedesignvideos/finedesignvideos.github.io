Part 1: The Potential Threat of Quantum Brutes

Our story starts with password-protected files. We rest easy with the belief that somebody who doesn't have the password will have a hard time unlocking the file. How justified is this belief though?

In many cases the decryption software is public knowledge. That means that we know the password-checking algorithm, we know the operations that will be carried out in order to check whether a password is the correct password for the locked file. We want to find a password such that if you run the operations on the password and the locked file, the operations end up telling you that the password is correct. There are two ways of going about this: we can either keep guessing passwords until we find such a password, or we can try analyzing the operations and try to logically find out which password would have led to acceptance by the operations. Like some kind of puzzle. This one is easy, I just have to look at the beginning of the file and reverse it and I'd get some password that would be accepted by the decryptor.

Of course, the designers of the password system know this and have chosen instructions so that it should be incredibly hard to solve the puzzle and find out the password. Now if the puzzles aren't impenetrable and you're some kind of genius who can actually solve these puzzles, then that would be a good way to go about finding the password. But for the sake of coming back to reality, let's say that analyzing the password puzzle is not something we're going to try at all.

We're going to try to find the password by guessing. We'll call such attempts brute-force attempts since we're going about it in a quite primitive way, just seeing whether our guesses are accepted by the operations without analyzing what it is that the operations are really doing.

If you're feeling more secure now thinking that such an approach is impractical, you're right. If the password can contain numbers and letters and 10 other symbols, and is 13 characters long, that's over a trillion trillion possibilities. If the password were chosen at random, and we started guessing passwords at the beginning of this millennium, by which I mean the 2000s, at the rate of one trillion guesses a second, more likely than not we'll still be guessing when we're in the 3000s. We could still be guessing even in the 33 thousands.

So we're safe from such brute-force attempts, right? Sounds like the only fears we should have are unlikely mega-geniuses. That was the case until the advent of quantum computing. When scientists realized that reality can exhibit weird behaviour, they asked whether we could use these weird behaviours to help our computers do things. In this opening episode, we'll look at a way in which quantum computers can change the game.

---

This is a long video, so here's the outline. We'll first take a short look at probabilistic computing. Then we'll see some quantum effects that manipulate probabilities in weird ways. We will then try to incorporate these effects in our computers. With our new quantum computers, we'll see a few surprising algorithms and lastly we'll see where all that leaves us.

< BREAK HERE IF YOU WANT >

So let's start with probabilistic computing. We can actually come up with a brute-force approach that guesses the correct password on the very first guess. Oh, and let's also work with 4 possible passwords, because 4 is a little easier to draw than a trillion trillion. So what we do is choose one of the 4 possibilities at random and use the password checker on it. At this point if we take a look at what happened, we'll see one of the 4 possibilities. It's true that one of them would have found the password, but the probability that's what actually happened is only 1/4. So even though one of the possibilities would have found the password, that is entirely useless to us unless we happened to observe that highly unlikely possibility. So this randomness doesn't help us. If there were a trillion trillion possibilities and the actual password was chosen at random, then even after 500 billion trillion guesses you've only seen half the passwords so there's only a half chance that you've found it by then.

Quantum mechanics has probabilities too but this arises from weird phenomena like superpositions and negative amplitudes. Young's famous double-slit experiment will be useful to explain some of this. The experiment involves an electron emitter, a wall with two slits and a wall behind the slits that acts as a detector. There's also a way to cover the slits. Electrons are emitted, pass through the slits and hit the detector. When only the right slit is covered, we see this pattern at the detector. When only the left slit is covered, we see a similar pattern. However when none of the slits are covered, we see a completely different pattern. The most mysterious parts of this pattern are the dark segments, like this one. An electron is more likely to be detected there when any of the two slits are open by themselves, but is not detected as much when both are open. Although this is a bit weird, it's actually a pattern people have seen before. If instead of detecting electrons, we were detecting moving particles, then this is how waves work. A wave propogates by moving neighbouring particles. The reason that can give us a dark spot here is that the part of the wave passing through the left slit could be pushing the particle at this spot to move up and down while the part of the wave passing through the right slit could be pushing the particle to move down and up, and so they cancel each other and no movement is detected. This is called wave interference.

But Young's double slit experiment is weirder. When electrons were emitted one at a time, this pattern still appeared. Since it's a single electron, how could it be moving like a wave? There are no intermediate particles to propagate a wave. And why do we detect an electron at only one spot on the detector if it's a wave? There's no simple answer to this, with Feynman famously stating that the deepest explanation of this phenomenon is just a description of the phenomenon itself. Nevertheless let's see the most popular explanation of how this comes about.

To figure out where an emitted electron is detected we have to look at every possible path it can take to the detector. Every possibility is associated with a probability. The detector will then detect an electron according to the probabilities associated with paths reaching that point.
The crazy happens because these probabilities can interfere with each other. At a dark spot, the path from one of the slits would be assigning a positive probability, and the path from the other slit would be assigning a negative probability, and so they cancel out and that's why there's nearly no probability of detecting an electron at these dark spots. Now I know negative probability doesn't make sense. Instead of probabilities we actually have what's called amplitudes, and these decide the probabilities. The probability of a possibility is just the square of the magnitude of the amplitude. These amplitudes can be positive, negative, or even complex. And although complex amplitudes are required to explain the pattern here, we'll stick with real amplitudes since that suffices for quantum computing. So here if the right path to this point had amplitude -0.1, in the absence of the left slit the electron would be detected there with probability .01. With both slits together the amplitude sums up to 0, and so the probability would also be 0. To talk about the state of an electron with multiple possible paths, we say that the electron is in a superposition of the various possibile paths. We'll depict a superpositon like this, each possibility associated with an amplitude. This is an electron with two possible paths, one to the right slit and one to the left slit. If we try to detect which slit it goes to, we'll get left slit with probability 1/rt2^2, or half, and same with the right slit. If we don't detect which slit it goes through, it stays in this superposition. Now each part of the superposition behaves independently. The electron at the left slit will reach the detector with a superposition that we'll call the left spread. We have to multiply the amplitudes of the left spread with 1/rt2 since that's the amplitude left slit had. Similarly the right slit state gives us the right spread superposition multiplied by 1/rt2. But to get the actual final state at the detector, we have to add up these two superpositions. That is, wherever the two superpositions have the same state, we add up the amplitudes. And that's how we calculate the state of the electron, and you can see it has 0 probability of being detected at point A. If you try to detect the slit that the electron passes through, it will change to a probabilistic state and you'll see only one of the possibilities, say the right slit. When that possibility evolves to the right spread it doesn't get interfered with. This agrees with experiment. If you try to detect what slit the electron went through, you'll no longer see those dark segments.

That was a lot! Feel free to pause and take a breather. We're now going to use these concepts to build a quantum computer.

< BREAK HERE IF YOU WANT >

To make it easier, let's think of a normal computer first.

Here's the memory of a normal computer, storing just two variables. One variable to tell which password we will be guessing, which we'll call the guess variable, and one to store the answer of whether that guess is the password. We'll call that the answer variable. The guess variable can take values 1,2,3 or 4 corresponding to the 4 passwords. The answer variable can take values 0 or 1, to represent whether the guess is the password or not. Let's also see what a password checker would do. We can set our memory to whatever state we want regardless of what the password is. Let's set it to 3,1 here. Now if 3 is not the password, then when we run the password checker the variable values should be 3,0. That's simple enough. Now let's see all of this in a quantum computer.

The memory of a quantum computer can be in a superposition of values. That is, a bunch of memory settings that a normal computer could take, along with amplitudes. Note that the squares of the amplitudes must add up to 1. We can set the quantum memory to whatever superposition we want as long as it satisfies this.

Now, does it make sense to talk of a quantum password checker? Turns out it does. We know the operations used by the password checker, so we just need to translate those operations to the quantum computer. It is possible to simulate normal operations on a quantum computer, so the quantum password checker should just be a straightforward quantum simulation of the normal password checker.

So what does this quantum password checker do? Let's assume that 2 is the correct password. In the same way that the superposition on slits gave us our final state, when we do an operation on a superposition, we do the operation for each possibility, multiply the amplitude, and then add the results to get our final state. So 1,1 should become 1,0, and both 2,0 and 2,1 should become 2,1. But when you add these up, the 2,1 memory setting gets amplitude 0 and you're left with 1/rt2 times 1,0. This is not a valid state, since the square of the amplitude just adds up to half. The quantum password checker we're thinking of breaks the laws of physics and isn't a valid quantum operation. This is not how the quantum simulation works. We'll see what quantum operations are valid, and then we'll see how the quantum simulation actually works.

To tell if an operation is permitted, look at what it does to each of the memory states. These resultant states should not overlap with each other. To understand what I mean by not overlapping, let's look at a few examples. Take the first two superpositions. They don't share any memory settings in common, so it makes sense to say that they don't overlap. But even the last two superpositions here don't overlap. The reason for that is that although they share memory setting in common, they share some positively and they share some negatively and it cancels out. Basically you look at the amplitudes of shared memory settings and multiply them. Add the products up over all the shared memory settings. If the result is 0, they don't overlap. The second and third superposition do overlap because they share only one memory setting and it doesn't get cancelled. So even the operation depicted here isn't valid. Let's change some of the superpositions, and you can verify that no two of these superpositions overlap. This would be a valid quantum operation.

So here's what the quantum password checker does: For a specific memory setting, it will check if the guessed password is correct, and if it is it will flip the answer bit from 0 to 1 or 1 to 0. If the guessed password is wrong, it will leave the answer bit as is. You can verify that this is a valid quantum operation. If the memory setting 2,0 becomes 2,1, then 2,1 must become 2,0 and so there's no overlap between the resulting states.

Now let's run the actual simulated quantum password checker on the superposition we had. We get a valid state as the result. It is my pleasure to now draw your attention to one of the tricks of quantum computing. Look at these two memory states, with amplitudes half and minus half. They both have 2 as their guess. The only difference is the answer variable. If 2 was not the password, then these answer bits would not flip and we'd get the same two settings with the same amplitudes in the result. If 2 is the password, then the answer bits would flip. But look at the effect of that: The result has the same two memory settings, but with the amplitudes now the negative of what they were. It's like our password checker didn't even care about the answer bit and just negated the amplitude if the guess was correct. That even sounds useful, because quantum computing gets its power from negative amplitudes.

So we've effectively created a simpler-looking password checker from the simulated password checker. It just negates amplitudes when the guess variable is the password, and it doesn't need an answer variable at all. You can see that the states are still non-overlapping reconfirming that this is a valid quantum operation.

Congratulations, you now what a quantum computer can do. Let's now see a quantum brute-force attempt.

< BREAK PLACE >

We start with our memory just being a superposition of two guesses as shown. To know what our output is when we send it through the password checker we need to know which password was correct. So let's analyze what happens in each case.

If neither of these was the password, nothing gets negated and so the state is the same. If 1 was the password, then its amplitude gets negated. Similarly for 2. And I know this shouldn't happen, but out of mathematical curiosity if both passwords were valid, the amplitude gets flipped for both the memory settings. Since we don't know the password we don't know which of these cases we are in. And if we try looking at it to see, then in each case we'll see 1 or 2 with probability half each. It gives us no information about the passwords. So it is imperative that we do not look at the answers yet and we try to make some interference happen.

We do that by performing a quantum operation, as shown. This operation changes the memrory setting 1 to 1/rt2 1 + 1/rt2 2, and the setting 2 to 1/rt2 1 - 1/rt2 2. Note that there's no overlap between these, so this is a valid quantum operation. Now let's see what this quantum operation does, starting with the case when none of them are the password. I recommend you pause and try these for yourself.

Okay, we know what the quantum operation does to each memory setting, so we do that while multiplying the amplitudes, and add them up. Note that the amplitudes of the 2 cancel each other, and we're left with just the memory setting 1 with amplitude 1. Very neat. In the case where 1 was the password, when we do the same process the amplitudes of 1 cancel each other and we're left with the memory setting 2 but with amplitude -1. In the case where 2 was the password, we get 2 again, but with amplitude 1. And in the case where both are valid passwords, we get 1 with amplitude -1. Now if we look to see what the state is after the password checker and quantum operation, and we see a 1, we know that either none of them was the password or bath were valid passwords. If we see a 2, then we know exactly one of them was a valid password but we don't know which. This is like the quantum computer version of the double slit experiment. It's actually even better. It's like you passed one electron through the slits, and with certainty you're able to differentiate between the cases when "exactly 1 slit is open" and the case when "0 or 2 slits are open". For our purposes we're assuming that there is only one correct password. So with just one use of the quantum password checker, we can find out with certainty whether or not that password is one of the two we're dealing with. Using this in the original question with a trillion trillion possible passwords, we can split it into 500 billion trillion pairs of passwords, and so with at most 500 billion trillion uses of the password checker, we will be able to find out which pair has the password. With one more guess, we can find out, with certainty, exactly what the password was. With the same number of uses of the password checker, probabilistic computing only gave you the answer with probability half.

Can we do better than that? Let's start with this quantum memory involving 4 possible passwords. Then we run the password checker. Then we apply this quantum operation. Again, I recommend you pause and work out what would happen when none are the password or when one of them is the password. If none were the password, we'd surprisingly end up with the same state as we started with. If the correct password was 1, the cancellations magically leave you with the memory setting 1. If the correct password was 2, you'll end up with 2, and so on. So when you look at your quantum memory, you know that the value you see is the password, unless none of the 4 were the password. In any case, you know for sure that the other 3 values do not include the password. With one use of the password checker you have eliminated 3 possibilities. So with atmost trillion trillion divided by 3 uses of the password checker you are guaranteed to single out the actual password. That's less than 340 billion trillion uses, which is an improvement from before.

It's not possible to eliminate more than 3 possibilities with a single query. However, our attempts haven't been very quantum-y, we always looked at the memory after just one use of the password checker. This forces our algorithm to be more probabilistic than quantum. If we consider algorithms where we do a lot of operations and then finally at the end look at the quantum memory, then there is in fact a way to extend the algorithm we just saw. It was discovered by Lov Grover and it is miraculous. It starts with a similar memory, but in a superposition of all possible passwords. Then it applies the password checker, and then does a quantum operation that is the natural extension of what we did earlier. I won't go into the details of it here. After this instead of looking at the memory, we again use the password checker and do the operation. And we repeatedly do this some number of times which I'll tell you soon. After all these operations, if there was no password we'd be left with the original state. But if s was the password, the superposition at the end would be s with amplitude really close to 1, like 1/trilliontrillion less than 1. So if you look at it, it's overwhelmingly likely that you'll see the correct password. And how many times does Grover need to use the password checker? Around 800 billion times, that's even less than 1 trillion. That's insane! And remember, it doesn't matter how complicated the encryption maker makes the password checking instructions, this one algorithm here will always find the password in under a trillion uses of the password checker. If we could build a quantum computer capable of creating the precise superpositions that we require, and if this quantum computer ran fast enough to do a trillion password checking operations per second, you'd be able to crack the password in about a second. But even if this computer can only do a million operations per second, it will still find the password in a matter of weeks.

This is scary. One thing we could do to counter it is to use longer passwords, making it 26 characters long would nullify that advantage. But a) we all know we're not gonna do that. A 26 character password, are you crazy? And b) even if we do that, that's only going to help until someone comes up with an algorithm that does performs even better than Grover's algorithm.

Once that happens, we might as well hand over our data to companies that have quantum computers. I mean, we can try to stop mathematicians from coming up with better quantum brute-force algorithms, but it's famously hard to stop mathematicians from working on interesting problems. You can have a Roman soldier kill Archimedes, but his final act will be to continue analyzing his diagrams. You can punish Sophie Germain for being a woman interest in maths by taking away her heating, but she will continue to read by candlelight, even making progress on Fermat's Last Theorem. You can challenge Galois to a duel in which he will be mortally wounded, but the previous night he would have spent writing down his ideas and spreading them to the world. You can refuse professorship to Emmy Noether for being a woman, and then kick her out of her university for being Jewish, but she will change the face of abstract algebra.

So I guess it's inevitable, we can't stop the mathematicians from bringing about the end of privacy and probably society itself. The possibility of a much more efficient quantum brute exists, and the world ends as soon as it becomes reality. Unless... Have you heard of the thing going around defeating enemies before they become reality? Calls itself the Shev. Maybe it can save us.

Wondering who the Shev is? Find our video on the Shev from the link in the description, it's got some really visually beautiful maths. Once you familiarize yourself with the Shev, we can move on with this story.

There are also some extra facts and details about quantum computing and Grover's algorithm that you can find in a bonus video at the end of the playlist.
