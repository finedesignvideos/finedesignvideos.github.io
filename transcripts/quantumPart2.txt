Showdown in the kingdom of the brutes

This video is the second part of a 2 video series on quantum brute-force algorithms for finding passwords. The link to the first video is in the description. It describes what I mean by a brute-force algorithm, introduces quantum computers and talks about some quantum algorithms. Another preferred prerequisite for this video is the series on Markov's theorem that talks about a famous polynomial that I called the Shev, which has very useful properties. The link to that is in the description as well. I'll start with the current video now.

We start this video in the realm of mathematical possibilities. In this realm you'll see statements that we don't know to be true and we don't know to be false, like the Riemann Hypothesis. You'll see mathematical objects that we don't know exist, but we don't know to be impossible either, like a neverending game of beggar-my-neighbour. But one of the most fascinating aspects of this realm is not the inhabitants themselves but the pacts they make. Take this statement, that says that the gap between two consecutive primes can never be much larger than the square root of the primes. It has a pact with the Riemann Hypothesis. Should the Riemann Hypothesis ascend to the world of mathematical reality, it will bring the statement about primes along with it. With such promises, the Riemann Hypothesis builds a large kingdom and gains importance in the realm. The Riemann Hypothesis will either ascend with its whole kingdom, or never ascend at all. Similarly the statement P=NP is known to have a vast kingdom. In this video we will look at the kingdom of the brute: What will happen if there exists a quantum brute-force algorithm for finding passwords more efficiently thn Grover's algorithm?

-------

To recap, we are analyzing the task of finding the password to a file, and we know the operations that are involved in checking a password. However, figuring out the password by analyzing the operations is too hard for us, so we want ti find the password just by trying out various passwords in the password checker. We had a trillion trillion possible passwords, and we reasoned that you need to make nearly a trillion trillion guesses to find the password and that is too costly.

But then we saw that if you use quantum computing you can do better. We saw some simple quantum algorithms and I claimed that Grover's algorithm can do this with at most 800 billion uses of the quantum password checker. But can that be brought down to a billion? A million? A thousand? Let's consider the possibility that it can be done in a billion guesses. Let's give this possibility a name. Let's call it SuperGrover.

We'll need to recall a bit about what quantum brute-force algorithms are like in order to analyze SuperGrover. The memory of a normal computer can be specified by specifying the memory setting, that is the value of each variable. A quantum computer's memory can be in a superposition of multiple memory settings. To perform an operation on our memory, we specify what each memory setting should become. For instance here's an example quantum operation. And what the quantum operation does to its memory is to just do the operation on each memory setting and add up the resulting superpositions. Although the calculations might look messy, the rules are really simple and you can ignore the calculations here. There were some further constraints on what operations are actually allowed by quantum mechanics, but they are not important to this video so I won't recap them. The last thing we have to recap is what the quantum password checking operation is like. And this was really simple, it just looked at the guess variable of a memory setting, and multiplies that setting with -1 if the guess was the correct password, and returns the original memory setting otherwise. Okay, recap done. Let's now take a look at SuperGrover's kingdom.



What's amazing about how these kingdoms grow is how they sometimes rope in subjects from seemingly unrelated fields of mathematics. We're going to do that now by viewing quantum brute-force algorithms from a slightly different perspective. Here's an example algorithm we had looked at. It had an initial memory and then we passed it through a password checker. To know the memory after it had gone through the password checker, we looked at the 4 possibilities of which passwords were valid. We calculated what happensin each case, and then did 4 calculations again when we performed the new quantum operation. This time around we'll treat the passwords as unknown and we'll see that this more informatively captures how the superposition depends on the valid passwords. This works particularly well if we define the unknowns x1, which is 0 if password 1 is not the correct password, and 1 if password 1 is the correct password. Similarly define x2 which is 0 if password 2 is not the correct password and 1 if password 2 is the correct password. Equipped with x1 and x2, let's see what the password checker does. If the guess is password 1, then the password checker attaches the amplitude (1-2x1) to it. It might look like I'm suddenly changing the password checker, but think about it. If password 1 is correct, then x1 is 1, and so the amplitude is -1. If password 1 is wrong, then x1 is 0, and so the amplitude is 1. This is exactly the same password checker, it's just written with variables now. Similarly the guess 2 gets the amplitude (1-2x2). We specified the behaviour of the password checker and we didn't even have to split it into cases.

So now we can redo our calculations in the algorithm. The superposition after the first password checker is just the memory setting 1 with amplitude (1-2x1) and the memory setting 2 with amplitude (1-2x2). You can check it against the cases we had individually computed earlier. Our next step was to do the new quantum operation shown here. When we do the operation, each memory setting changes accordingly and we then add up the superpositions to get the final superposition. And this is it. Now when we look at this final state, we know the probability of seeing 1 and the probability of seeing 2. It's just the square of their amplitudes.

The probability of seeing 1 is (1-x1-x2)^2. If none of the passwords are valid, that's (1-0-0)^2, so with probability 1 we will see the value 1. If exactly one of the passwords were valid, we would see (1-1)^2, so we will always see the value 2. And if somehow both passwords were valid, we would again see the value 1, because we'd see that with probability (1-2)^2. So with this one expression we were able to fully analyze all the cases. At the same time we have made a connection between quantum algorithms and a certain type of polynomials where there's more than one variable, called multivariate polynomials.

Let's use this same logic for any quantum algorithm. We start with some superposition. All it's amplitudes are just plain numbers. When we pass it through the password checker, the amplitudes now get multiplied by something of the form (1-2xi). So the amplitudes are now degree 1 polynomials. Then we do some other operation. To calculate the new amplitudes, we see that we're just multiplying our earlier amplitudes by numbers and then adding them up. This doesn't change the degree of the amplitudes, it just mixes them together. Now if you pass it through the password checker again, the amplitudes again get multipled by things of the form (1-2xi). Now the amplitudes become degree 2. Another operation will create superpositions and add them up, so they will still be degree 2 polynomials. Then if we pass it through another password checker, they become degree 3 polynomials and so it continues. So if we run SuperGrover, our final state can be represented by a superposition where the amplitudes are multivariate polynomials of degree 1 billion. At this point we look at the superposition and based on the memory state that we see we should be able to tell what the password was. The probability that we see a particular memory state is now a degree billion polynomial squared. When we square a polynomial its degree doubles, so that's a polynomial of degree 2 billion. Now there would be some memory settings for which SuperGrover would have said that the password is 1. We can find out the probability that SuperGrover says that the password is password 1 by summing the probabilities corresponding to those memory settings. Let's call this resultant polynomial p1(x1,x2 and so on). For short we'll just call it p1 without mentioning the variables everytime. p1 also has degree 2 billion. We can also find the polynomial p2 which is the probability that SuperGrover says that the correct password is password #2. And we can calculate p3, p4 and so on till ptrilliontrillion. Since we are assuming that SuperGrover does actually find the correct password, here is what we know about the polynomials:

If we evaluate p1 with x1=1 and all other xs equal to 0, then the answer should be really close to 1 since if 1 is the only valid password then SuperGrover should have a high probability of saying that password 1 is the correct password. If we evaluate p1 with x2=1 and all other xs equal to 0, then the answer should be really close to 0 since SuperGrover should not be answering that password 1 is the correct answer. We can make similar statements about p2, p3 and all the other polynomials. Nowe have a trillion trillion polynomials. That's too much. Let's change that to just one polynomial

Here's a new polynomial p_{SG} where the SG stands for SuperGrover. It is defined as p_{SG} = x1 times p1 + x2 times p2 + x3 times p3 + ... and so on for all the trillion trillion terms. The degree of p_{SG} has increased by 1 and is now 2B+1 because we've multiplied a variable with each p. Let's now see some beautiful properties of this polynomial. If p_{SG} gets as input x1=0,x2=0 and all xs =0, then since each term in the addition has an x variable multiplied, they will all become 0. If p_{SG} gets input with only x1=1, then all the other terms will become 0, and the output will be the same as the ouput of p1. We know p1 is close to 1 when x1 is 1 and all other xs are 0. So p_{SG} is also close to 1. This same logic works for any input where exactly one of the xs is 1. Only one term will not be zero, and that one will be close to 1. There's one more property that p_{SG} has. No matter which xs I set to 0 and which I set to 1, the value of p_{SG} is always between 0 and 1. For instance, let's take the case when only x1 and x2 are 1. Then this is the same as p1 + p2. p1 will give you the probability that SuperGrover outputs 1 when 1 and 2 are the valid passwords. Similarly p2 is the probability that SuperGrover will output 2. So p1+p2 is the probability that SuperGrover outputs 1 or 2 when 1 and 2 are the valid passwords. Since it's a probability, it must lie between 0 and 1.

A polynomial with these three properties would be considered a very structured polynomial. We don't know if there is apolynomial satisfying properties a,b and c with degree at most 2B+1. If SuperGrover actually exists, then we can get from it the polynomial p_{SG} which would satisfy all these properties. So such a nice structured polynomial takes up an importance residence in SuperGrover's kingdom.

However, multivariate polynomials are quite tough to imagine, it would be nicer if we had a polynomial with just one variable that had some nice structure. And we can actually find such a polynomial using something called symmetrization. I'll show this by an example.

# 1.5 x1x2x3 - 1.4 x1x2 - 1.45 x1x3 - 1.5 x2x3 + .9 x1 + .95 x2 + x3
Here is a multivariate polynomial. It doesn't have any x_1^2 term or similar terms with exponents, but that's because if x_1 is only taking values 0 or 1, x_1^2 is the same as x_1. So from now on all polynomials won't have exponents. This polynomial in particular takes the value 0 when all xs are 0, takes a value close to 1 when exactly one of them is 1, and it is still between 0 and 1 on all other values as well. It's not the best polynomial like this, but I'm taking it to show how symmetrization works. If I change the role of x1 and x2, I get this new polynomial. all the nice properties remain. This is because the properties are symmetric, they treats each x the same. So in particular if I do all possible interchanging of variables and I get all those different polynomials and I take their average, I should get a new polynomial which I'll call p_symmetric, and it will also have the same properties: It should still be 0 when all x's are 0, because each of the polynomials were 0 and we're taking their average. Now if I set x1 to 1, it should be close to 1 because all the polynomials would have been. And for any value of x, psymmetric should be between 0 and 1, again because all the polynomials were. So why is this psymmetric more interesting? Because the coefficients of x1x2 and x1x3 and x2x3 should all be the same! Think about it, the coefficient of x1x2 in psymmetric comes from averaging all the polynomials with all the variables switched around. So the coefficient of x1x2 in psymmetric should be the average of the coefficients of x1x2, x1x3, and x2x3 in p. And same for x1x3 and x2x3. Similarly the coefficients of x1, of x2, and of x3 in psymmetric will all be the average of their coefficients in p.

Now that we have such a neat polynomial, we do one last trick. (x1+x2+x3)^3 is just 6x1x2x3 + 6x1x2 + 6x1x3 + 6x2x3 + x1 + x2 + x3. (x1 + x2 + x3)^2 is 2x1x2 + 2x1x3 + 2x2x3 + x1 + x2 + x3.

So (x1+x2+x3)^2/4 is 1.5x1x2x3 + 1.5x1x2 + 1.5x1x3 + 1.5x2x3 + x1/4 + x2/4 + x3/4. We've gotten the degree 3 term the same as psymmetric. To get the degree 2 terms the same, we add -2.9/2 times (x1 + x2 + x3)^2 term. The coefficients of the linear term won't match, but we can add an appropriate amount of (x1+x2+x3).

This is what symmetrization is. Given a structured multivariate polynomial like we had, it's a way to come up with another multivariate polynomial with the same structure but that is essentially univariate. Essentially univariate because it's really just the polynomial 0.25x^3 - 1.45x^2 + 2.1x, which we'll call u, applied to the input x1+x2+x3. We can find the value of u(0) by setting all xis to 0. We can find u(1) by setting exactly one of the xis to 1, u(2) by setting two xis to 1 and u(3) by setting all xis to 1. So u(0)=0, u(1) is .9. And u(2) and u(3) are both between 0 and 1 because they are the values of psymmetric when 2 and 3 of the xs are set to 1 respectively.

RERECORD FROM HERE? NEED TO EDIT VIDEO AS WELL.

This polynomial u is also really beautiful and it takes centerplace in the kingdom of SuperGrover. Let's take another look at it. A univariate polynomial of degree 2billion plus one that evaluates to 0 on input 0, evaluates near 1 on input 1, and evaluates between 0 and 1 on inputs 2,3, and so on till trillion trillion. Unfortunately for SuperGrover, its kingdom is starting to trespass into a conquered region. You see, this polynomial u very quickly goes from 0 to near 1, and then stays between 0 and 1 for a long time, as if it were in one of the arenas from the series on Markov's theorem.

Indeed let's take this polynomial u and do some simple operations on it, squeezing it, scaling it, and shifting it, so that it actually fits the arena. The length of the arena has changed from a trillion trillion to 2, so the intervals are of size 2/TT. Now we know it takes value -1 at x=-1, goes near 1 at x=-1 + 2/TT, and stays between -1 and 1 at -1+4/TT,-1+6/TT,...,1. None of these modifications changed its degree. But it might not actually fit the arena yet. We know that at regular intervals it is between -1 and 1, but maybe between these intervals it goes outside the arena, perhaps reaching a value of 1.1. So let's expand the arena so that it fits.

Uh, hello? Oops, I did not mean to interrupt, let me move out of the way. I am the Shev, I was called here.

Oh, hi Shev. We were just looking at this miraculous 2 billion plus one degree polynomial that stays in the arena here. It has a really large slope at the left side of the arena.

Oh, is that so? Let me fit myself in the arena, and stretch so that I also fit exactly in this arena. So, how much slope does your polynomial have?

Well, since the intervals are of width 2/TT, and it goes from near -1 to near 1 in one interval, it has to have a slope of at least TT/2.

Ah, but that's not possible. A Shev of degree 2B+1 would have the maximum slope in the normal arena, where it has a slope at around 4BB. In this enlarged arena, it would be the same Shev enlarged which has the maximum slope, so that's a slope of around 4.4BB. Much smaller than TT/2. Your polynomial must have degree larger than 600B in order to do what you claim.

Maybe we got the arena wrong, maybe it goes really far outside the arena in the intervals.

That's not possible either. Even if it goes to 1.1, that means it must have a slope of TT/10 between the intervals just to be able to touch 1.1 and come back to 1 in an interval of size 2/TT. You can do the maths assuming it goes far outside 1 and you'll see that you hit the same issue, that's too large a slope for such a small degree polynomial.

And so this special polynomial u cannot exist. But the polynomial u was part of SuperGrover's kingdom. If SuperGrover ever becomes reality, the polynomial u must become reality. So the Shev didn't just stop the polynomial u, it stopped SuperGrover itself from ever becoming reality. It doesn't matter how smart the mathematicians are, they can never make a brute-force quantum algorithm that finds a password among trillion trillion passwords with just a billion uses of the password checker, or if we calcaulated more carefully, even with 300B uses of the password checker. Shev just saved society!